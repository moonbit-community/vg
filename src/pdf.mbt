// Basic PDF rendering backend

/// PDF document structure
pub struct PdfDocument {
  width : Double
  height : Double
  objects : Array[String]
  object_count : Int
} derive(Show)

/// Create a new PDF document
pub fn new_pdf(width : Double, height : Double) -> PdfDocument {
  { width, height, objects: [], object_count: 0 }
}



/// Convert color to PDF color values (0-1 range)
fn color_to_pdf(c : Color) -> String {
  "\{c.r} \{c.g} \{c.b} rg"
}

/// Convert point to PDF coordinates (flip Y axis)
fn point_to_pdf(p : Point, height : Double) -> String {
  "\{p.x} \{height - p.y}"
}









/// Convert a path to PDF path commands
fn path_to_pdf_commands(path : Path, height : Double) -> Array[String] {
  let commands = Array::new()
  
  for segment in path.0 {
    match segment {
      MoveTo(p) => commands.push("\{point_to_pdf(p, height)} m")
      LineTo(p) => commands.push("\{point_to_pdf(p, height)} l")
      CurveTo(cp1, cp2, end) => 
        commands.push("\{point_to_pdf(cp1, height)} \{point_to_pdf(cp2, height)} \{point_to_pdf(end, height)} c")
      QCurveTo(cp, end) => {
        // Convert quadratic to cubic BÃ©zier for PDF
        // PDF doesn't support quadratic curves natively
        commands.push("% Quadratic curve converted to cubic")
        commands.push("\{point_to_pdf(cp, height)} \{point_to_pdf(cp, height)} \{point_to_pdf(end, height)} c")
      }
      EArcTo(_, _, _, _, _, end) => {
        // Simplified arc for PDF - just line to end point
        commands.push("% Elliptical arc simplified")
        commands.push("\{point_to_pdf(end, height)} l")
      }
      Close => commands.push("h")  // Close path
    }
  }
  
  commands
}





// ===== OBJECT-ORIENTED API METHODS =====

/// Add an object to the PDF document (OO-style)
fn PdfDocument::add_object(self : PdfDocument, obj : String) -> PdfDocument {
  let new_objects = Array::new()
  for o in self.objects {
    new_objects.push(o)
  }
  new_objects.push(obj)
  { width: self.width, height: self.height, objects: new_objects, object_count: self.object_count + 1 }
}

/// Render a circle to PDF (OO-style)
pub fn PdfDocument::render_circle(self : PdfDocument, center : Point, radius : Double, color : Color) -> PdfDocument {
  let kappa = 0.5522847498
  let offset = radius * kappa
  
  let content = 
    "q\n" +  // Save graphics state
    "\{color_to_pdf(color)}\n" +
    "\{point_to_pdf(point(center.x, center.y - radius), self.height)} m\n" +  // Move to top
    // Four cubic curves to approximate circle
    "\{point_to_pdf(point(center.x + offset, center.y - radius), self.height)} \{point_to_pdf(point(center.x + radius, center.y - offset), self.height)} \{point_to_pdf(point(center.x + radius, center.y), self.height)} c\n" +
    
    point_to_pdf(point(center.x + radius, center.y + offset), self.height) + " " +
    point_to_pdf(point(center.x + offset, center.y + radius), self.height) + " " +
    point_to_pdf(point(center.x, center.y + radius), self.height) + " c\n" +
    
    point_to_pdf(point(center.x - offset, center.y + radius), self.height) + " " +
    point_to_pdf(point(center.x - radius, center.y + offset), self.height) + " " +
    point_to_pdf(point(center.x - radius, center.y), self.height) + " c\n" +
    
    point_to_pdf(point(center.x - radius, center.y - offset), self.height) + " " +
    point_to_pdf(point(center.x - offset, center.y - radius), self.height) + " " +
    point_to_pdf(point(center.x, center.y - radius), self.height) + " c\n" +
    
    "f\n" +  // Fill
    "Q"       // Restore graphics state
  
  self.add_object(content)
}

/// Render a rectangle to PDF (OO-style)
pub fn PdfDocument::render_rectangle(self : PdfDocument, x : Double, y : Double, width : Double, height : Double, color : Color) -> PdfDocument {
  let content = 
    "q\n" +  // Save graphics state
    color_to_pdf(color) + "\n" +
    "\{x} \{self.height - y - height} \{width} \{height} re\n" +  // Rectangle
    "f\n" +  // Fill
    "Q"       // Restore graphics state
  
  self.add_object(content)
}

/// Render a line to PDF (OO-style)
pub fn PdfDocument::render_line(self : PdfDocument, start : Point, end : Point, color : Color, thickness : Double) -> PdfDocument {
  let content = 
    "q\n" +  // Save graphics state
    color_to_pdf(color) + " RG\n" +  // Stroke color
    thickness.to_string() + " w\n" +  // Line width
    "1 J\n" +  // Round line caps
    point_to_pdf(start, self.height) + " m\n" +  // Move to start
    point_to_pdf(end, self.height) + " l\n" +    // Line to end
    "S\n" +   // Stroke
    "Q"        // Restore graphics state
  
  self.add_object(content)
}

/// Render text to PDF (OO-style)
pub fn PdfDocument::render_text(self : PdfDocument, text : String, pos : Point, size : Double, color : Color) -> PdfDocument {
  let content = 
    "q\n" +  // Save graphics state
    "BT\n" +  // Begin text
    "/F1 " + size.to_string() + " Tf\n" +  // Font and size
    color_to_pdf(color) + " rg\n" +  // Text color
    point_to_pdf(pos, self.height) + " Td\n" +  // Text position
    "(" + text + ") Tj\n" +  // Show text
    "ET\n" +  // End text
    "Q"        // Restore graphics state
  
  self.add_object(content)
}

/// Render a path to PDF (OO-style)
pub fn PdfDocument::render_path(self : PdfDocument, path : Path, color : Color) -> PdfDocument {
  let path_commands = path_to_pdf_commands(path, self.height)
  
  let mut content = "q\n"  // Save graphics state
  content = content + color_to_pdf(color) + "\n"
  
  for cmd in path_commands {
    content = content + cmd + "\n"
  }
  
  content = content + "f\n"  // Fill
  content = content + "Q"     // Restore graphics state
  
  self.add_object(content)
}

/// Convert to PDF string (OO-style)
pub fn PdfDocument::to_string(self : PdfDocument) -> String {
  let mut pdf = "%PDF-1.4\n"
  
  // PDF Header
  pdf = pdf + "1 0 obj\n<<\n/Type /Catalog\n/Pages 2 0 R\n>>\nendobj\n\n"
  
  // Pages object
  pdf = pdf + "2 0 obj\n<<\n/Type /Pages\n/Kids [3 0 R]\n/Count 1\n>>\nendobj\n\n"
  
  // Page object
  pdf = pdf + "3 0 obj\n<<\n/Type /Page\n/Parent 2 0 R\n"
  pdf = pdf + "/MediaBox [0 0 " + self.width.to_string() + " " + self.height.to_string() + "]\n"
  pdf = pdf + "/Resources <<\n/Font << /F1 << /Type /Font /Subtype /Type1 /BaseFont /Helvetica >> >>\n>>\n"
  pdf = pdf + "/Contents 4 0 R\n>>\nendobj\n\n"
  
  // Content stream
  let mut content_stream = ""
  for obj in self.objects {
    content_stream = content_stream + obj + "\n"
  }
  
  pdf = pdf + "4 0 obj\n<<\n/Length " + content_stream.length().to_string() + "\n>>\nstream\n"
  pdf = pdf + content_stream
  pdf = pdf + "endstream\nendobj\n\n"
  
  // Cross-reference table
  pdf = pdf + "xref\n0 5\n"
  pdf = pdf + "0000000000 65535 f \n"
  pdf = pdf + "0000000009 65535 n \n"
  pdf = pdf + "0000000074 65535 n \n"
  pdf = pdf + "0000000120 65535 n \n"
  pdf = pdf + "0000000300 65535 n \n"
  
  // Trailer
  pdf = pdf + "trailer\n<<\n/Size 5\n/Root 1 0 R\n>>\n"
  pdf = pdf + "startxref\n" + (pdf.length() + 50).to_string() + "\n%%EOF"
  
  pdf
}


